import React, { useState, useEffect, useRef } from 'react';
import { GoogleGenAI, Type } from "@google/genai";
import { MominAILogo, SendIcon, HTMLFileIcon, TSXFileIcon, CSSFileIcon, FileIcon } from './icons.tsx';

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

// A simple in-memory representation of the generated files
type AppFile = {
    name: string;
    content: string;
};

interface IDEProps {
    onLogout: () => void;
}

const IDE = ({ onLogout }: IDEProps) => {
    const [files, setFiles] = useState<AppFile[]>([]);
    const [activeFileName, setActiveFileName] = useState<string | null>(null);
    const [prompt, setPrompt] = useState<string>('');
    const [chatHistory, setChatHistory] = useState<{ role: 'user' | 'model', text: string }[]>([]);
    const [isLoading, setIsLoading] = useState<boolean>(false);
    const [previewUrl, setPreviewUrl] = useState<string>('');
    const chatEndRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        setChatHistory([{ role: 'model', text: 'Hello! Describe the application you want to build.' }]);
    }, []);

    useEffect(() => {
        chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [chatHistory]);

    const getFileIcon = (fileName: string) => {
        if (fileName.endsWith('.html')) return <HTMLFileIcon />;
        if (fileName.endsWith('.tsx') || fileName.endsWith('.jsx')) return <TSXFileIcon />;
        if (fileName.endsWith('.css')) return <CSSFileIcon />;
        return <FileIcon />;
    };

    const updatePreview = (generatedFiles: AppFile[]) => {
        const htmlFile = generatedFiles.find(f => f.name === 'index.html' || f.name.endsWith('.html'));
        if (!htmlFile) {
            console.error('index.html not found in generated files.');
            const basicHtml = `<!DOCTYPE html><html><head><title>Error</title></head><body><p>Error: Main HTML file was not generated by the AI.</p></body></html>`;
            const blob = new Blob([basicHtml], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            if (previewUrl) URL.revokeObjectURL(previewUrl);
            setPreviewUrl(url);
            return;
        }
        
        const blob = new Blob([htmlFile.content], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        
        if (previewUrl) {
            URL.revokeObjectURL(previewUrl);
        }
        
        setPreviewUrl(url);
    };

    const handlePromptSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!prompt || isLoading) return;

        setIsLoading(true);
        const currentPrompt = prompt;
        setChatHistory(prev => [...prev, { role: 'user', text: currentPrompt }]);
        setPrompt('');

        const systemInstruction = `You are an expert web developer AI. Your task is to generate a complete, production-ready, single-page web application based on the user's prompt.
        
        RULES:
        1.  Always generate all necessary files, including index.html, index.tsx (or index.js), and a style file (e.g., index.css).
        2.  For React apps, use esm.sh for imports (e.g., "https://esm.sh/react").
        3.  The main script file must be imported in index.html as a module (e.g., <script type="module" src="/index.tsx"></script>). The path should be relative.
        4.  Your response MUST be a single, valid JSON object.
        5.  The JSON object must match this exact schema: { "files": [{ "name": "path/to/file.ext", "content": "file content" }] }. Do not include any other text, markdown, or explanations outside of the JSON object.`;
        
        const fileSchema = {
          type: Type.OBJECT,
          properties: {
            files: {
              type: Type.ARRAY,
              items: {
                type: Type.OBJECT,
                properties: {
                  name: { type: Type.STRING },
                  content: { type: Type.STRING },
                },
                required: ["name", "content"],
              },
            },
          },
          required: ["files"],
        };
        

        try {
            setChatHistory(prev => [...prev, { role: 'model', text: '' }]);
            
            const responseStream = await ai.models.generateContentStream({
                model: 'gemini-2.5-flash',
                contents: [
                    ...chatHistory.map(m => ({ role: m.role, parts: [{ text: m.text }]})),
                    { role: 'user', parts: [{ text: currentPrompt }]}
                ],
                config: {
                    systemInstruction: systemInstruction,
                    responseMimeType: "application/json",
                    responseSchema: fileSchema,
                },
            });

            let accumulatedResponse = '';
            for await (const chunk of responseStream) {
                accumulatedResponse += chunk.text;
                setChatHistory(prev => {
                    const newHistory = [...prev];
                    newHistory[newHistory.length - 1].text = accumulatedResponse;
                    return newHistory;
                });
            }
            
            const jsonString = accumulatedResponse.trim();
            const parsed = JSON.parse(jsonString);
            
            if (parsed.files && Array.isArray(parsed.files)) {
                setFiles(parsed.files);
                setActiveFileName(parsed.files.find(f => f.name.includes('src/'))?.name || parsed.files[0]?.name || null);
                updatePreview(parsed.files);
            } else {
                throw new Error("Invalid JSON structure from AI.");
            }

        } catch (error) {
            console.error("Error generating content:", error);
            const errorMessage = `Sorry, something went wrong. The AI response might be malformed or an API error occurred. Details: ${error.message}`;
            setChatHistory(prev => {
                const newHistory = [...prev];
                newHistory[newHistory.length - 1].text = errorMessage;
                return newHistory;
            });
        } finally {
            setIsLoading(false);
        }
    };
    
    const activeFile = files.find(f => f.name === activeFileName);

    const styles: { [key: string]: React.CSSProperties } = {
        ide: { display: 'flex', height: '100vh', flexDirection: 'column', backgroundColor: '#0A0A0A' },
        header: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '0.5rem 1rem', borderBottom: '1px solid var(--border-color)', flexShrink: 0 },
        main: { display: 'flex', flex: 1, overflow: 'hidden' },
        panel: { height: '100%', overflow: 'auto', borderRight: '1px solid var(--border-color)' },
        chatPanel: { width: '25%', display: 'flex', flexDirection: 'column' },
        codePanel: { width: '40%', display: 'flex', flexDirection: 'column' },
        previewPanel: { width: '35%', borderRight: 'none' },
        chatMessages: { flex: 1, padding: '1rem', overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '1.5rem' },
        message: { maxWidth: '90%', padding: '0.5rem 1rem', borderRadius: '0.75rem', lineHeight: 1.5, whiteSpace: 'pre-wrap' },
        userMessage: { backgroundColor: 'var(--accent)', color: 'white', alignSelf: 'flex-end', borderBottomRightRadius: '0.125rem' },
        modelMessage: { backgroundColor: 'var(--gray-dark)', alignSelf: 'flex-start', borderBottomLeftRadius: '0.125rem' },
        chatForm: { display: 'flex', padding: '1rem', borderTop: '1px solid var(--border-color)' },
        chatInput: { flex: 1, backgroundColor: 'var(--background-secondary)', border: '1px solid var(--border-color)', borderRadius: '0.5rem', padding: '0.75rem', color: 'white', fontSize: '1rem', resize: 'none', marginRight: '0.5rem' },
        chatButton: { backgroundColor: 'var(--accent)', border: 'none', borderRadius: '0.5rem', padding: '0.75rem', display: 'flex', alignItems: 'center', justifyContent: 'center' },
        fileExplorer: { padding: '1rem', borderBottom: '1px solid var(--border-color)' },
        fileItem: { display: 'flex', alignItems: 'center', gap: '0.5rem', padding: '0.5rem', borderRadius: '0.25rem', userSelect: 'none' },
        codeEditor: { flex: 1, padding: '1rem', whiteSpace: 'pre-wrap', overflow: 'auto', fontFamily: 'monospace', fontSize: '0.9rem', color: '#d4d4d4', backgroundColor: '#1e1e1e' },
        iframe: { width: '100%', height: '100%', border: 'none', backgroundColor: 'white' },
    };

    return (
        <div style={styles.ide} className="ide-container">
            <header style={styles.header}>
                <MominAILogo width={100} height={22} />
                <button onClick={onLogout} style={{...styles.chatButton, backgroundColor: 'var(--gray-dark)'}}>Logout</button>
            </header>
            <main style={styles.main} className="ide-main">
                <div style={styles.chatPanel} className="ide-panel">
                    <div style={styles.chatMessages}>
                        {chatHistory.map((msg, i) => (
                            <div key={i} style={{...styles.message, ...(msg.role === 'user' ? styles.userMessage : styles.modelMessage)}}>
                                {msg.text}
                                {isLoading && i === chatHistory.length -1 && <span className="blinking-cursor"></span>}
                            </div>
                        ))}
                         <div ref={chatEndRef} />
                    </div>
                    <form onSubmit={handlePromptSubmit} style={styles.chatForm}>
                        <textarea 
                            value={prompt}
                            onChange={e => setPrompt(e.target.value)}
                            onKeyDown={e => { if (e.key === 'Enter' && !e.shiftKey) handlePromptSubmit(e) }}
                            style={styles.chatInput}
                            placeholder="e.g., a landing page for a SaaS product..."
                            rows={2}
                            disabled={isLoading}
                        />
                        <button type="submit" style={styles.chatButton} disabled={isLoading}><SendIcon /></button>
                    </form>
                </div>
                <div style={styles.codePanel} className="ide-panel">
                    <div style={styles.fileExplorer}>
                        <h3 style={{marginBottom: '1rem'}}>Files</h3>
                        {files.length > 0 ? files.map(file => (
                            <div 
                                key={file.name} 
                                style={{
                                    ...styles.fileItem, 
                                    backgroundColor: activeFileName === file.name ? 'var(--accent)' : 'transparent'
                                }}
                                onClick={() => setActiveFileName(file.name)}
                            >
                                {getFileIcon(file.name)}
                                <span>{file.name}</span>
                            </div>
                        )) : <p style={{color: 'var(--gray)', fontSize: '0.9rem'}}>No files generated yet.</p>}
                    </div>
                    <pre style={{margin: 0, flex: 1, overflow: 'hidden'}}><code style={styles.codeEditor}>
                        {activeFile ? activeFile.content : 'Select a file to view its content.'}
                    </code></pre>
                </div>
                <div style={{...styles.previewPanel, borderRight: 'none'}} className="ide-panel">
                    {previewUrl ? 
                        <iframe style={styles.iframe} src={previewUrl} title="Live Preview" sandbox="allow-scripts allow-same-origin" /> :
                        <div style={{display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: 'var(--gray)'}}>
                            Preview will appear here.
                        </div>
                    }
                </div>
            </main>
            <style>{`
                .blinking-cursor {
                    display: inline-block;
                    width: 8px;
                    height: 1.2em;
                    background-color: #ccc;
                    animation: blink 1s step-end infinite;
                    margin-left: 4px;
                    vertical-align: text-bottom;
                }
                @keyframes blink {
                    50% { opacity: 0; }
                }
                
                @media (max-width: 1024px) {
                    .ide-main {
                        flex-direction: column;
                    }
                    .ide-panel {
                        width: 100% !important;
                        height: 100vh;
                        border-right: none !important;
                        border-bottom: 1px solid var(--border-color);
                    }
                }
            `}</style>
        </div>
    );
};

export default IDE;